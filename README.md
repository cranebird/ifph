ifph
====

「関数プログラミング入門 Haskellで学ぶ原理と技法」("Introduction to Functional Programming using Haskell")への私的メモ。

## 第１０章　モナド

機能。

| 機能 | 説明 | 登場人物 |
|--------|--------|--------|
| 基本 | 基本となる評価器(10.2.1) | Term, eval |
| 例外 | エラー処理(10.2.2) | Exc(Raise Exception, Return a), Exception |
| 状態 | 計算回数のカウント(10.2.3) | St, MkSt(State -> (a, State)), State |
| 出力 | 実行ステップのトレース(10.2.4) | Out, MkOut (Output, a), Output |

## モナドによる評価器 + モナドの複合

| 型クラス | 定義 | 演算 | 対応する標準ライブラリ |
|--------|-----|----|----|
| モナド | Monad m | return, >>=  |
| 恒等モナド | Id a |      | Control.Monad.Identity |
| 例外モナド | ExMonad m | raise | Control.Monad.Error ? |
| 状態モナド | StMonad m | tick  | Control.Monad.State | 
| 出力モナド | ShowMonad m | showMonad | Control.Monad.Writer ? |
| モナド変換子 | Transformer t | promote | |
| 例外モナドのモナド変換子 | EXC | promote, recover | ErrorT ? |
| 状態モナドのモナド変換子 | STT | promote, apply | StateT |

### 10.4 モナドの複合 

例外処理と状態の両方を使えるようなモナドを、既にある例外モナドと状態モナドを組み合わせることで作りたい。
ここで、モナド変換子 t という物を考える。モナド変換子 t は特定のモナド m0 と任意のモナド m を組み合わせる。
- t は任意のモナド m を受けとり、新しいモナド m' を作る。つまり m' は Monad のインスタンス。
- 新しいモナド m' はモナド則を見たす。
- 新しいモナド m' は、モナド m0 の性質を持つ。つまり m' は m0 のインスタンス。
- 新しいモナド m' は、モナド m の性質を持つ。つまり m' は m のインスタンス。

このようなモナド変換子 t が特定のモナドに対して作ることができれば、任意のモナドを組み合わせることができる。
ここでは実際に、「任意のモナド m と例外モナドを複合するモナド変換子 EXC」、および、「任意のモナド m と状態モナドを複合するモナド変換子 STT」を定義する。これらを使うことで、状態モナドと例外モナドを複合したモナド(名前は付けられていない)を作成する。
複合の方法は、モナド変換子を適用する順番に対応して2つあり、その結果が微妙に異なることを後で議論する。

- 準備: 型クラス ExMonad, StMonad, ShowMonad を定義する。
- 準備: 任意のモナドと例外モナドを複合するモナド変換子 EXC を定義する。(10.4.1)

- m がモナドのとき、EXC m がモナドであることを要請する。そしてこれは実際に定義できる。(10.4.1 p.341)
- m がモナドのとき、EXC m が例外モナドであることを要請する。そしてこれは実際に定義できる。(10.4.1 p.342)
- m が X モナドのとき、EXC m が X モナドであることを要請する。これは promote を使って定義する。

### 型合わせ

理解のために、10.4 を少し別の辿りかたをしてみる。

型クラス `ExMonad`, `StMonad` を定義した状態で `eval` を定義した、と考える。`eval` は型シグネチャを与えなくても、
以下のように型推論される。
    eval :: (StMonad m, ExMonad m) => Term -> m Int 

この時点では、 `ExMonad` および `StMonad` のインスタンスは無いため、コンパイルは通っているが計算を実行することはできない。
実行するためには、型を合わせる必要がある。


